<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://anique.ml/feed.xml" rel="self" type="application/atom+xml" /><link href="https://anique.ml/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-05-13T13:02:30+00:00</updated><id>https://anique.ml/feed.xml</id><title type="html">blank</title><subtitle>Anique&apos;s Website.
</subtitle><entry><title type="html">a post with giscus comments</title><link href="https://anique.ml/blog/2022/giscus-comments/" rel="alternate" type="text/html" title="a post with giscus comments" /><published>2022-12-10T15:59:00+00:00</published><updated>2022-12-10T15:59:00+00:00</updated><id>https://anique.ml/blog/2022/giscus-comments</id><content type="html" xml:base="https://anique.ml/blog/2022/giscus-comments/"><![CDATA[<p>This post shows how to add GISCUS comments.</p>]]></content><author><name></name></author><category term="sample-posts" /><category term="external-services" /><summary type="html"><![CDATA[an example of a blog post with giscus comments]]></summary></entry><entry><title type="html">understanding jax’s scan function</title><link href="https://anique.ml/blog/2022/understanding_scan/" rel="alternate" type="text/html" title="understanding jax’s scan function" /><published>2022-09-05T00:00:00+00:00</published><updated>2022-09-05T00:00:00+00:00</updated><id>https://anique.ml/blog/2022/understanding_scan</id><content type="html" xml:base="https://anique.ml/blog/2022/understanding_scan/"><![CDATA[<h2 id="why-use-jaxlaxscan">Why use <code class="language-plaintext highlighter-rouge">jax.lax.scan</code></h2>

<p>Jax is a neural network library used mostly by Google. Jax converts all your implementation into a graph which is executed
on your CPU, GPU or TPU. There are two main advantages of using Jax for your implementation:</p>
<ul>
  <li>It is comparatively faster than it’s competitor Pytorch</li>
  <li>It allows for significantly easier implementation for low level neural network concepts (albeit being harder for high-level</li>
  <li>ideas)</li>
</ul>

<p>Jax allows you to <code class="language-plaintext highlighter-rouge">jit</code> your functions. <code class="language-plaintext highlighter-rouge">jit</code> stands for Just-In-Time compilation. This makes your function significantly fast
since it is compiled into something native to the GPU<d-footnote>or any device you compile for.</d-footnote>. However, the drawback 
is that the amount of memory that your function will use, has to be pre-specified. This means that functions containing loops
have to be changed, since the length of the loop can be arbitrary. <code class="language-plaintext highlighter-rouge">jax.lax.scan</code> allows you to get around this limitation by
allowing you to define a loop with pre-specified length. But how does it work?</p>

<hr />

<p>According to the jax <a href="https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.scan.html">documentation</a>, the following code is 
essentially a translation of the function in pythonic form:</p>

<pre><code class="language-python3">def scan(f, init, xs, length=None):
  if xs is None:
    xs = [None] * length
  carry = init
  ys = []
  for x in xs:
    carry, y = f(carry, x)
    ys.append(y)
  return carry, np.stack(ys)
</code></pre>

<p>The code may be a little convoluted to understand. A simpler way to understand it is to look at some simple examples. The <code class="language-plaintext highlighter-rouge">scan</code> 
function takes three parameters and scans over the third argument. The first arguments is a function to execute over each scan iteration.
The second argument is some <code class="language-plaintext highlighter-rouge">pytree</code> structure which we initially start from. Lets look at a simple example.</p>

<pre><code class="language-python3">scan(lambda x, y: (x+y, y+2,), 0, [1, 2, 3])
</code></pre>

<p>The above code essentially scans through the list <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code> and for each element, returns a tuple consisting of the previous element and the current element. The output of the above code will be:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre></div></div>
<p>Here <code class="language-plaintext highlighter-rouge">x</code> is the carry argument which is initialized to <code class="language-plaintext highlighter-rouge">0</code>. <code class="language-plaintext highlighter-rouge">y</code> is each element of the array <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code> passed sequentially to the function. In the first pass <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">y</code> is 1. The return value is <code class="language-plaintext highlighter-rouge">(x+y, y+2,) = (0+1,  1+2,) = (1, 3,)</code>. For the next iteration, <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">1</code>, since <code class="language-plaintext highlighter-rouge">1</code> is the value of the carry returned in the last iteration and <code class="language-plaintext highlighter-rouge">y</code> is <code class="language-plaintext highlighter-rouge">2</code>, since <code class="language-plaintext highlighter-rouge">2</code> is the next value in the input array. Thus, <code class="language-plaintext highlighter-rouge">(x+y, y+2,) = (1+2,  2+2,) = (3, 4,)</code>. In the next iteration, the final value of the carry is <code class="language-plaintext highlighter-rouge">6</code>, while the final <code class="language-plaintext highlighter-rouge">y+2</code> is <code class="language-plaintext highlighter-rouge">5</code>. Thus, the <code class="language-plaintext highlighter-rouge">scan</code> function returns <code class="language-plaintext highlighter-rouge">6</code>(the carry) and <code class="language-plaintext highlighter-rouge">[3, 4, 5]</code>(all the <code class="language-plaintext highlighter-rouge">y+2</code> concatenated)</p>

<p>Here we used a simple example, but the scan function can be used over more complicated arguments, such as the training loop of a neural network. This makes it possible to jit compile the entire training process, resulting in a large gain in training speed.</p>]]></content><author><name>Anique Tahir</name></author><summary type="html"><![CDATA[jax.lax.scan is a function which allows jit-able loops]]></summary></entry><entry><title type="html">New Blog</title><link href="https://anique.ml/blog/2022/website/" rel="alternate" type="text/html" title="New Blog" /><published>2022-08-06T00:00:00+00:00</published><updated>2022-08-06T00:00:00+00:00</updated><id>https://anique.ml/blog/2022/website</id><content type="html" xml:base="https://anique.ml/blog/2022/website/"><![CDATA[<p>Since my focus has shifted, I have decided to put down the old website. The old blog mainly consisted of 
posts about software development and random things I was doing. I had not updated it in several years since
my focus had shifted more towards my PhD studies. This new website will follow suit.</p>

<p>For any information about the old content, please feel free to reach out to me.</p>]]></content><author><name></name></author><category term="website" /><category term="website" /><summary type="html"><![CDATA[hello]]></summary></entry></feed>